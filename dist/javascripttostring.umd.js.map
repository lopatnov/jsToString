{"version":3,"file":"javascripttostring.umd.js","sources":["../src/javascripttostring.ts"],"sourcesContent":["import getObjectType from \"@lopatnov/get-internal-type\";\r\n\r\nexport interface IJ2SOptions {\r\n  includeFunctionProperties?: boolean; // default true\r\n  includeFunctionPrototype?: boolean; // default true\r\n  includeBuffers?: boolean; // default true\r\n  nestedObjectsAmount?: number; // default Number.POSITIVE_INFINITY\r\n  nestedArraysAmount?: number; // default Number.POSITIVE_INFINITY\r\n  nestedFunctionsAmount?: number; // default Number.POSITIVE_INFINITY\r\n}\r\n\r\ninterface RefInstance {\r\n  historyRef: Array<any>,\r\n  source: any\r\n}\r\n\r\nvar refs: RefInstance[] = [];\r\nvar counter = 0;\r\n\r\ninterface IJ2SHistory {\r\n  references: any[];\r\n  nestedObjectsLeft: number;\r\n  nestedArraysLeft: number;\r\n  nestedFunctionsLeft: number;\r\n}\r\n\r\nfunction fillNativeFunctions(ext: any, obj: any, objName: string, fromPrototype: boolean = true) {\r\n  const arrNames = Object.getOwnPropertyNames(fromPrototype ? obj.prototype: obj);\r\n  const protoPath = fromPrototype ? '.prototype.' : '.';\r\n  for (let name of arrNames) {\r\n    if (['caller', 'callee', 'arguments'].indexOf(name) < 0) {\r\n      ext[`${objName}${protoPath}${name}`] = fromPrototype ? obj.prototype[name as any] : obj[name as any];\r\n    }\r\n  }\r\n}\r\n\r\nconst nativeFunctions = (function(){\r\n  const functions: any = {};\r\n  fillNativeFunctions(functions, Array, 'Array', false);\r\n  fillNativeFunctions(functions, Array, 'Array');\r\n  fillNativeFunctions(functions, JSON, 'JSON', false);\r\n  fillNativeFunctions(functions, Object, 'Object', false);\r\n  fillNativeFunctions(functions, Object, 'Object');\r\n  fillNativeFunctions(functions, Function, 'Function', false);\r\n  fillNativeFunctions(functions, Function, 'Function');\r\n  fillNativeFunctions(functions, Date, 'Date', false);\r\n  fillNativeFunctions(functions, String, 'String');\r\n  functions.Function = Function;\r\n  return functions;\r\n}());\r\n\r\nfunction numberToString(value: number): string {\r\n  if (Number.isNaN(value)) {\r\n    return \"Number.NaN\";\r\n  }\r\n  switch (value) {\r\n    case Number.POSITIVE_INFINITY:\r\n      return \"Number.POSITIVE_INFINITY\";\r\n    case Number.NEGATIVE_INFINITY:\r\n      return \"Number.NEGATIVE_INFINITY\";\r\n    case Number.EPSILON:\r\n      return \"Number.EPSILON\";\r\n    case Number.MAX_SAFE_INTEGER:\r\n      return \"Number.MAX_SAFE_INTEGER\";\r\n    case Number.MIN_SAFE_INTEGER:\r\n      return \"Number.MIN_SAFE_INTEGER\";\r\n    case Number.MAX_VALUE:\r\n      return \"Number.MAX_VALUE\";\r\n    case Number.MIN_VALUE:\r\n      return \"Number.MIN_VALUE\";\r\n    case Math.PI:\r\n      return \"Math.PI\";\r\n    case Math.E:\r\n      return \"Math.E\";\r\n    case Math.LN10:\r\n      return \"Math.LN10\";\r\n    case Math.LN2:\r\n      return \"Math.LN2\";\r\n    case Math.LOG10E:\r\n      return \"Math.LOG10E\";\r\n    case Math.LOG2E:\r\n      return \"Math.LOG2E\";\r\n    case Math.SQRT1_2:\r\n      return \"Math.SQRT1_2\";\r\n    case Math.SQRT2:\r\n      return \"Math.SQRT2\";\r\n    default:\r\n      return String(value);\r\n  }\r\n}\r\n\r\nfunction symbolToString(value: any): string {\r\n  switch (value) {\r\n    case Symbol.asyncIterator:\r\n    case Symbol.hasInstance:\r\n    case Symbol.isConcatSpreadable:\r\n    case Symbol.iterator:\r\n    case Symbol.match:\r\n    case Symbol.prototype:\r\n    case Symbol.replace:\r\n    case Symbol.search:\r\n    case Symbol.species:\r\n    case Symbol.split:\r\n    case Symbol.toPrimitive:\r\n    case Symbol.toStringTag:\r\n    case Symbol.unscopables:\r\n      return value.description;\r\n    default:\r\n      let description = value.description ? `\"${value.description}\"` : \"\";\r\n      return `Symbol(${description})`;\r\n  }\r\n}\r\n\r\nfunction dateToString(value: Date): string {\r\n  if (isNaN(value.getTime())) {\r\n    return `new Date(${value.toString()})`;\r\n  }\r\n  return `new Date(${value.toISOString()})`;\r\n}\r\n\r\nfunction errorToString(value: any): string {\r\n  let message = JSON.stringify(value.message),\r\n    fileName = JSON.stringify(value.fileName),\r\n    lineNumber = JSON.stringify(value.lineNumber);\r\n  return `new Error(${message}, ${fileName}, ${lineNumber})`;\r\n}\r\n\r\nfunction arrayToString(\r\n  value: Array<any>,\r\n  options: IJ2SOptions,\r\n  history: IJ2SHistory\r\n): string {\r\n  if (value.length === 0) return \"[]\";\r\n  let arrayValues = value.reduce(\r\n    (x1: any, x2: any, index: number) => {\r\n      history.references.push(index.toString());\r\n      let str = !!x1 ? `${x1}, ` : '';\r\n      str += stringifyRef(x2,options,history);\r\n      history.references.pop();\r\n      return str;\r\n    }, '');\r\n  return attachActions(getLocalRefs(value), `[${arrayValues}]`);\r\n}\r\n\r\nfunction getLocalRefs(value: any) {\r\n  return refs.filter(x => x.source === value)\r\n}\r\n\r\nfunction attachActions(localRefs: RefInstance[], result: string) {\r\n  if (localRefs.length > 0) {\r\n    counter = (counter++) % Number.MAX_SAFE_INTEGER;\r\n    const localName = `___j2s_${counter}`;\r\n    const actions = localRefs.reduce((x1: string, x2: RefInstance) => {\r\n      const action = converToAction(localName, x2);\r\n      refs.splice(refs.indexOf(x2), 1);\r\n      return x1 + action;\r\n    }, '');\r\n    return `(function(){ var ${localName} = ${result}; ${actions} return ${localName}; }())`;\r\n  }\r\n  return result;\r\n}\r\n\r\nfunction converToAction(localName: string, r: RefInstance) {\r\n  const destIndex = r.historyRef.indexOf(r.source);\r\n  if (destIndex < 0) {\r\n    return '';\r\n  }\r\n\r\n  const dest = r.historyRef.slice(destIndex);\r\n  let sourceObj: any;\r\n  let path = '';\r\n  for (let i = 0; i < dest.length; i++) {\r\n    const destObj = dest[i];\r\n    if (destObj === r.source) {\r\n      path = localName;\r\n      sourceObj = r.source;\r\n    } else if (typeof destObj === 'string') {\r\n      path += `['${destObj.replace(/'/gi, '\\\\\\'')}']`;\r\n      sourceObj = sourceObj[destObj];\r\n    } else if (destObj !== sourceObj) {\r\n      return '';\r\n    }\r\n  }\r\n\r\n  return `${path} = ${localName}; `;\r\n}\r\n\r\nfunction typedArrayToString(\r\n  value: any,\r\n  options: IJ2SOptions,\r\n  history: IJ2SHistory\r\n): string {\r\n  let arr = Array.from(value),\r\n    arrString = arrayToString(arr, options, history),\r\n    constructorName = value.constructor.name;\r\n  return `new ${constructorName}(${arrString})`;\r\n}\r\n\r\nfunction setToString(\r\n  value: Set<any>,\r\n  options: IJ2SOptions,\r\n  history: IJ2SHistory\r\n): string {\r\n  let setValues: string[] = [];\r\n\r\n  value.forEach((value1: any, value2: any, set: Set<any>) => {\r\n    setValues.push(stringifyRef(value2, options, history));\r\n  });\r\n\r\n  if (setValues.length === 0) return \"new Set()\";\r\n\r\n  return `new Set([${setValues.join(\", \")}])`;\r\n}\r\n\r\nfunction mapToString(\r\n  value: Map<any, any>,\r\n  options: IJ2SOptions,\r\n  history: IJ2SHistory\r\n): string {\r\n  let mapValues: string[] = [];\r\n\r\n  value.forEach((indexValue: any, key: any) => {\r\n    mapValues.push(\r\n      `[${stringifyRef(key, options, history)}, ${stringifyRef(\r\n        indexValue,\r\n        options,\r\n        history\r\n      )}]`\r\n    );\r\n  });\r\n\r\n  if (mapValues.length === 0) return \"new Map()\";\r\n\r\n  return `new Map([${mapValues.join(\", \")}])`;\r\n}\r\n\r\nfunction objectToString(\r\n  value: any,\r\n  options: IJ2SOptions,\r\n  history: IJ2SHistory\r\n): string {\r\n  let objectValues = [];\r\n\r\n  for (let propertyName in value) {\r\n    if (value.hasOwnProperty(propertyName)) {\r\n      history.references.push(propertyName);\r\n      let propertyValue = stringifyRef(value[propertyName], options, history);\r\n      history.references.pop();\r\n      if (propertyValue !== \"undefined\") {\r\n        if (!(/^[a-zA-Z]+$/).test(propertyName)) {\r\n          propertyName = `\"${propertyName}\"`;\r\n        }\r\n        objectValues.push(`${propertyName}: ${propertyValue}`);\r\n      }\r\n    }\r\n  }\r\n\r\n  if (objectValues.length === 0) return \"{}\";\r\n\r\n  return attachActions(getLocalRefs(value), `{\\n${objectValues.join(\",\\n\")}\\n}`);\r\n}\r\n\r\nfunction functionPropertiesToString(\r\n  functionName: string,\r\n  value: any,\r\n  options: IJ2SOptions,\r\n  history: IJ2SHistory\r\n): string {\r\n  let result = \"\";\r\n  for (let propertyName in value) {\r\n    if (value.hasOwnProperty(propertyName)) {\r\n      history.references.push(propertyName);\r\n      let propertyValue = stringifyRef(value[propertyName], options, history);\r\n      history.references.pop();\r\n      if (propertyValue !== \"undefined\") {\r\n        result += `${functionName}.${propertyName} = ${propertyValue};\\n`;\r\n      }\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\nfunction functionToString(\r\n  value: any,\r\n  options: IJ2SOptions,\r\n  history: IJ2SHistory\r\n): string {\r\n  let functionName = value.name || \"anonymousFunction\";\r\n  let functionObject = options.includeFunctionProperties\r\n    ? functionPropertiesToString(functionName, value, options, history)\r\n    : \"\";\r\n  history.references.push('prototype');\r\n  let functionPrototype = options.includeFunctionPrototype\r\n    ? functionPropertiesToString(\r\n        `${functionName}.prototype`,\r\n        value.prototype,\r\n        options,\r\n        history\r\n      )\r\n    : \"\";\r\n  history.references.pop();\r\n\r\n  let functionStr = String(value);\r\n  if (functionStr.indexOf('[native code]') > -1 && functionStr.length < 100) {\r\n    for (const nfName in nativeFunctions) {\r\n      if (nativeFunctions[nfName] === value) {\r\n        functionStr = nfName\r\n      }\r\n    }\r\n  }\r\n  if (!functionObject && !functionPrototype) {\r\n    return functionStr;\r\n  }\r\n\r\n  return attachActions(getLocalRefs(value), `(function(){\\n var ${functionName} = ${String(\r\n    functionStr\r\n  )};\\n ${functionObject}\\n ${functionPrototype}\\n return ${functionName};\\n}())`);\r\n}\r\n\r\nfunction arrayBufferToString(\r\n  value: ArrayBuffer,\r\n  options: IJ2SOptions,\r\n  history: IJ2SHistory\r\n): string {\r\n  if (!options.includeBuffers) return \"undefined\";\r\n  let str = typedArrayToString(new Int8Array(value), options, history);\r\n  return `(${str}).buffer`;\r\n}\r\n\r\nfunction dataViewToString(\r\n  value: DataView,\r\n  options: IJ2SOptions,\r\n  history: IJ2SHistory\r\n): string {\r\n  if (!options.includeBuffers) return \"undefined\";\r\n  let bufString = arrayBufferToString(value.buffer, options, history);\r\n  return `new DataView(${bufString}, ${value.byteOffset}, ${value.byteLength})`;\r\n}\r\n\r\n/**\r\n * Converts to string the value, if it wasn't before\r\n * @param value the value, that converts to string\r\n * @param references the references to stringified objects\r\n */\r\nfunction stringify(\r\n  value: any,\r\n  options: IJ2SOptions,\r\n  history: IJ2SHistory\r\n): string {\r\n  switch (getObjectType(value)) {\r\n    case \"undefined\":\r\n      return \"undefined\";\r\n    case \"null\":\r\n      return \"null\";\r\n    case \"boolean\":\r\n      return String(value);\r\n    case \"regexp\":\r\n      return String(value);\r\n    case \"string\":\r\n      return JSON.stringify(value);\r\n    case \"number\":\r\n      return numberToString(value);\r\n    case \"bigint\":\r\n      return `BigInt(${value})`;\r\n    case \"symbol\":\r\n      return symbolToString(value);\r\n    case \"date\":\r\n      return dateToString(value);\r\n    case \"error\":\r\n      return errorToString(value);\r\n    case \"array\":\r\n      return arrayToString(value, options, history);\r\n    case \"typedarray\":\r\n      return typedArrayToString(value, options, history);\r\n    case \"set\":\r\n      return setToString(value, options, history);\r\n    case \"map\":\r\n      return mapToString(value, options, history);\r\n    case \"object\":\r\n      return objectToString(value, options, history);\r\n    case \"function\":\r\n    case \"generatorfunction\":\r\n      return functionToString(value, options, history);\r\n    case \"arraybuffer\":\r\n      return arrayBufferToString(value, options, history);\r\n    case \"dataview\":\r\n      return dataViewToString(value, options, history);\r\n    case \"promise\":\r\n    case \"generator\":\r\n      return \"undefined\";\r\n    default:\r\n      return JSON.stringify(value);\r\n  }\r\n}\r\n\r\n/**\r\n * Stringify the value, if it wasn't before\r\n * @param value the value, that converts to string\r\n * @param references the references to stringified objects\r\n */\r\nfunction stringifyRef(\r\n  value: any,\r\n  options: IJ2SOptions,\r\n  history: IJ2SHistory\r\n): string {\r\n  const index = history.references.indexOf(value);\r\n  if (index < 0 || typeof(history.references[index]) === 'string') {\r\n    let objectType = getObjectType(value);\r\n    let referencesLength = history.references.length;\r\n    history.references.push(value);\r\n    switch (objectType) {\r\n      case \"object\":\r\n        if (history.nestedObjectsLeft <= 0) return \"undefined\";\r\n        history.nestedObjectsLeft--;\r\n        break;\r\n      case \"array\":\r\n      case \"typedarray\":\r\n        if (history.nestedArraysLeft <= 0) return \"undefined\";\r\n        history.nestedArraysLeft--;\r\n        break;\r\n      case \"function\":\r\n      case \"generatorfunction\":\r\n        if (history.nestedFunctionsLeft <= 0) return \"undefined\";\r\n        history.nestedFunctionsLeft--;\r\n        break;\r\n    }\r\n\r\n    let refString = stringify(value, options, history);\r\n\r\n    history.references.splice(referencesLength);\r\n    switch (objectType) {\r\n      case \"object\":\r\n        history.nestedObjectsLeft++;\r\n        break;\r\n      case \"array\":\r\n      case \"typedarray\":\r\n        history.nestedArraysLeft++;\r\n        break;\r\n      case \"function\":\r\n      case \"generatorfunction\":\r\n        history.nestedFunctionsLeft++;\r\n        break;\r\n    }\r\n\r\n    return refString;\r\n  } else {\r\n    refs.push({\r\n      historyRef: history.references.slice(0),\r\n      source: value\r\n    })\r\n  }\r\n  return \"null\";\r\n}\r\n\r\n/**\r\n * Converts JavaScript value to string\r\n * @param value the value of any type\r\n * @param options [optional] The options of conversion\r\n */\r\nfunction javaScriptToString(value: any, options?: IJ2SOptions): string {\r\n  options = options || {};\r\n  let concreteOptions: IJ2SOptions = {\r\n    includeFunctionProperties:\r\n      options.includeFunctionProperties === undefined\r\n        ? true\r\n        : options.includeFunctionProperties,\r\n    includeFunctionPrototype:\r\n      options.includeFunctionPrototype === undefined\r\n        ? true\r\n        : options.includeFunctionPrototype,\r\n    includeBuffers:\r\n      options.includeBuffers === undefined ? true : options.includeBuffers,\r\n    nestedObjectsAmount:\r\n      options.nestedObjectsAmount === undefined\r\n        ? Number.POSITIVE_INFINITY\r\n        : options.nestedObjectsAmount,\r\n    nestedArraysAmount:\r\n      options.nestedArraysAmount === undefined\r\n        ? Number.POSITIVE_INFINITY\r\n        : options.nestedArraysAmount,\r\n    nestedFunctionsAmount:\r\n      options.nestedFunctionsAmount === undefined\r\n        ? Number.POSITIVE_INFINITY\r\n        : options.nestedFunctionsAmount\r\n  };\r\n\r\n  return stringify(value, concreteOptions, {\r\n    references: [value],\r\n    nestedObjectsLeft: concreteOptions.nestedObjectsAmount as number,\r\n    nestedArraysLeft: concreteOptions.nestedArraysAmount as number,\r\n    nestedFunctionsLeft: concreteOptions.nestedFunctionsAmount as number\r\n  });\r\n}\r\n\r\nexport default javaScriptToString;\r\n"],"names":["refs","counter","fillNativeFunctions","ext","obj","objName","fromPrototype","protoPath","arrNames_1","Object","getOwnPropertyNames","prototype","_i","name_1","indexOf","nativeFunctions","functions","Array","JSON","Function","Date","String","numberToString","value","Number","isNaN","POSITIVE_INFINITY","NEGATIVE_INFINITY","EPSILON","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","MAX_VALUE","MIN_VALUE","Math","PI","E","LN10","LN2","LOG10E","LOG2E","SQRT1_2","SQRT2","symbolToString","Symbol","asyncIterator","hasInstance","isConcatSpreadable","iterator","match","replace","search","species","split","toPrimitive","toStringTag","unscopables","description","dateToString","getTime","toString","toISOString","errorToString","stringify","message","fileName","lineNumber","arrayToString","options","history","length","arrayValues","reduce","x1","x2","index","references","push","str","stringifyRef","pop","attachActions","getLocalRefs","filter","x","source","localRefs","result","localName_1","actions","action","converToAction","splice","localName","r","destIndex","historyRef","sourceObj","dest","slice","path","i","destObj","typedArrayToString","arrString","from","constructor","name","setToString","setValues","forEach","value1","value2","set","join","mapToString","mapValues","indexValue","key","objectToString","objectValues","propertyName","hasOwnProperty","propertyValue","test","functionPropertiesToString","functionName","functionToString","functionObject","includeFunctionProperties","functionPrototype","includeFunctionPrototype","functionStr","nfName","arrayBufferToString","includeBuffers","Int8Array","dataViewToString","buffer","byteOffset","byteLength","getObjectType","objectType","referencesLength","nestedObjectsLeft","nestedArraysLeft","nestedFunctionsLeft","refString","javaScriptToString","concreteOptions","undefined","nestedObjectsAmount","nestedArraysAmount","nestedFunctionsAmount"],"mappings":"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"}